# v1.2 改进说明

## 改进内容

### 1. 对话历史只保存原始消息 ✅

**问题：** 用户输入"重写这个章节"，但对话历史保存的是：
```
【用户引用的项目文件】
- @Chapter 7 神陨滩头·诺曼底逆潮 (路径: 章节内容/2025-10-02T05-51-00-896Z_...)
💡 提示：使用 read_file 工具读取这些文件的内容。

【用户问题】
重写这个章节
```

**解决方案：** 分离原始消息和系统提示，只保存原始消息到历史

**改动文件：**
1. `server.js`（第 231、316-317 行）
   - 接收 `originalMessage` 参数
   - 优先保存原始消息到历史

2. `public/app.js`（第 1046-1049 行）
   - 发送请求时同时传递 `prompt`（完整提示）和 `originalMessage`（原始消息）
   - `prompt` 用于 AI 处理
   - `originalMessage` 用于保存到历史

**效果：**
- ✅ 对话历史清爽简洁
- ✅ 不包含系统生成的文件引用提示
- ✅ 只显示用户真实输入的内容

---

### 2. 文件列表实时自动刷新 ✅

**问题：** 
- AI 创建或修改文件后，文件列表不更新
- 必须手动刷新页面才能看到新文件
- 用户体验不佳

**解决方案：** 
1. 监听 SSE `file_update` 事件，自动刷新文件列表
2. AI 完成后（`done` 事件）刷新所有已展开的文件夹
3. 手动保存文件后也刷新对应文件夹

**改动文件：**

1. `public/app.js`（第 358-389 行）- 新增刷新函数：
   ```javascript
   async function refreshFileFolder(type) {
       // 刷新单个文件夹
   }
   
   async function refreshAllFileFolders() {
       // 刷新所有已展开的文件夹
   }
   ```

2. `public/app.js`（第 1189-1199 行）- SSE 事件处理：
   ```javascript
   } else if (data.type === 'file_update') {
       showFileDiff(type, filename, oldContent, newContent);
       await refreshFileFolder(type);  // 🔥 自动刷新
   } else if (data.type === 'done') {
       await loadOverview();
       await refreshAllFileFolders();  // 🔥 完成后刷新
   }
   ```

3. `public/app.js`（多处）- 手动保存时刷新：
   - 第 651 行：编辑器保存后刷新
   - 第 699 行：预览区域保存后刷新
   - 第 944 行：接受 AI 修改后刷新

**效果：**
- ✅ AI 创建文件 → 自动出现在文件列表
- ✅ AI 修改文件 → 自动刷新显示
- ✅ 手动保存文件 → 立即更新列表
- ✅ 无需刷新页面，体验流畅

---

## 测试验证

### 测试 1：对话历史简洁性

1. 引用一个文件（如 @Chapter 7）
2. 输入"重写这个章节"
3. 生成完成后，查看 `novels/未来神战/conversation-history.json`
4. **预期：** 只看到"重写这个章节"，不包含系统提示

### 测试 2：文件列表实时刷新

**场景 A：AI 创建新文件**
1. 展开"章节内容"文件夹
2. 输入"创建一个测试章节，保存到章节内容"
3. **预期：** AI 保存后，新文件自动出现在列表中（无需刷新）

**场景 B：AI 修改文件**
1. 展开"章节内容"文件夹
2. 引用某章节，输入"重写开头"
3. **预期：** AI 修改后，文件列表自动刷新（显示最新修改时间）

**场景 C：手动保存文件**
1. 打开某个文件编辑
2. 修改内容并保存
3. **预期：** 保存后文件列表自动刷新

---

## 升级步骤

1. **停止服务器**：按 `Ctrl+C`
2. **重新启动**：`npm run web`
3. **清空浏览器缓存**（可选但推荐）：按 `Ctrl+Shift+R` 强制刷新
4. **测试功能**：按上述测试场景验证

---

## 技术细节

### 为什么要分离原始消息和完整提示？

**原始消息（originalMessage）：**
- 用户真实输入
- 保存到对话历史
- 用于显示给用户看

**完整提示（prompt）：**
- 包含文件引用信息（路径、提示词）
- 发送给 AI 处理
- 让 AI 知道有哪些文件可以读取
- 不保存到历史（避免冗余）

**设计理念：**
> 对话历史应该像聊天记录一样简洁，只保留用户真实意图，不包含系统内部的提示词拼接。

### 文件列表刷新策略

**智能刷新：**
- 只刷新**已展开**的文件夹（避免不必要的请求）
- 根据事件类型选择刷新范围：
  - `file_update`：刷新单个文件夹
  - `done`：刷新所有已展开的文件夹
  - 手动保存：刷新对应文件夹

**性能优化：**
- 不会无限制刷新所有文件夹
- 不会重复刷新同一个文件夹
- 使用 `async/await` 确保顺序执行

---

## 相关文档

- [JSON 截断问题解决方案](./json-truncation-fix.md)
- [v1.1 功能说明](./v1.1-features.md)

---

## 常见问题

### Q: 为什么对话历史还是有点长？

A: 现在已经只保存原始消息了。如果你使用 @ 引用了文件，会在显示时附带文件引用标签（如 `@Chapter 7`），但系统提示不会保存。

### Q: 文件列表没有自动刷新？

A: 请确认：
1. 文件夹是否已展开（折叠的文件夹不会刷新）
2. 是否重启了服务器使改动生效
3. 是否清空了浏览器缓存

### Q: 能否手动刷新文件列表？

A: 目前最简单的方法是折叠再展开文件夹。未来可以添加一个刷新按钮。

---

## 未来改进方向

1. **文件列表右键菜单**：添加"刷新"、"重命名"、"删除"等操作
2. **文件搜索功能**：在文件列表中快速搜索文件
3. **对话历史可视化**：在 UI 中查看和管理对话历史
4. **性能优化**：使用 WebSocket 代替 SSE，更高效的实时通信

